/* Generated by re2c 0.9.9 on Sun Jan 29 13:55:08 2006 */
#line 1 "GUI/detail/gss-grammar.h.re"
#include <memory>
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <iostream>
using std::auto_ptr;

#include <string>
#include <stdexcept>
#include <iostream>


namespace OmfgGUI{
template<class T>
struct TGrammar {
#define self (static_cast<T *>(this))
~TGrammar() { free(buffer); }
struct Token{ typedef std::auto_ptr<Token> ptr;

virtual ~Token() {}
};

struct STRING : public Token {
typedef std::auto_ptr<STRING> ptr;
#define CONSTRUCT(b_, e_) STRING(T& g, char const* b_, char const* e_)

	CONSTRUCT(b, e) : str(b, e) { }

	std::string str;

#undef CONSTRUCT
};
void next() {
#define YYCTYPE char
#define YYCURSOR curp
#define YYLIMIT limit
#define YYMARKER marker
#define YYFILL(n) fill(n)
retry:
begin = curp;
goto append; append:
#line 44 "GUI/detail/gss-grammar.h.re"

switch(state) {case 0:

#line 49 "<stdout>"
{
	YYCTYPE yych;
	goto yy0;
	++YYCURSOR;
yy0:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	switch(yych){
	case 0x00:	goto yy25;
	case 0x09:	case 0x0D:	case ' ':	goto yy19;
	case 0x0A:	goto yy21;
	case '"':	goto yy23;
	case '#':	goto yy5;
	case '%':	case '(':
	case ')':	case '-':	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':	case '\\':	case '_':	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy17;
	case ',':	goto yy15;
	case '.':	goto yy3;
	case '/':	goto yy18;
	case ':':	goto yy7;
	case ';':	goto yy9;
	case '{':	goto yy11;
	case '}':	goto yy13;
	default:	goto yy27;
	}
yy2:
#line 54 "GUI/detail/gss-grammar.h.re"
{  cur = 8; curData.reset(new STRING(*self, begin, YYCURSOR)); return; }
#line 136 "<stdout>"
yy3:	++YYCURSOR;
	switch((yych = *YYCURSOR)) {
	case '%':	case '(':
	case ')':	case '-':
	case '.':
	case '/':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':	case '\\':	case '_':	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy34;
	default:	goto yy4;
	}
yy4:
#line 47 "GUI/detail/gss-grammar.h.re"
{  cur = 1; return; }
#line 208 "<stdout>"
yy5:	++YYCURSOR;
	goto yy6;
yy6:
#line 48 "GUI/detail/gss-grammar.h.re"
{  cur = 2; return; }
#line 214 "<stdout>"
yy7:	++YYCURSOR;
	goto yy8;
yy8:
#line 49 "GUI/detail/gss-grammar.h.re"
{  cur = 3; return; }
#line 220 "<stdout>"
yy9:	++YYCURSOR;
	goto yy10;
yy10:
#line 50 "GUI/detail/gss-grammar.h.re"
{  cur = 4; return; }
#line 226 "<stdout>"
yy11:	++YYCURSOR;
	goto yy12;
yy12:
#line 51 "GUI/detail/gss-grammar.h.re"
{  cur = 5; return; }
#line 232 "<stdout>"
yy13:	++YYCURSOR;
	goto yy14;
yy14:
#line 52 "GUI/detail/gss-grammar.h.re"
{  cur = 6; return; }
#line 238 "<stdout>"
yy15:	++YYCURSOR;
	goto yy16;
yy16:
#line 53 "GUI/detail/gss-grammar.h.re"
{  cur = 7; return; }
#line 244 "<stdout>"
yy17:	yych = *++YYCURSOR;
	goto yy35;
yy18:	yych = *++YYCURSOR;
	switch(yych){
	case '/':	goto yy32;
	default:	goto yy35;
	}
yy19:	++YYCURSOR;
	goto yy20;
yy20:
#line 55 "GUI/detail/gss-grammar.h.re"
{ 
#define linecounter() (++this->line)
#define skip() goto retry
#define append() goto append
#define setstate(x_) (state = (x_))
 skip(); 
#undef setstate
#undef append
#undef skip
#undef linecounter
 cur = 9; return; }
#line 267 "<stdout>"
yy21:	++YYCURSOR;
	goto yy22;
yy22:
#line 77 "GUI/detail/gss-grammar.h.re"
{ 
#define linecounter() (++this->line)
#define skip() goto retry
#define append() goto append
#define setstate(x_) (state = (x_))
 linecounter(); skip(); 
#undef setstate
#undef append
#undef skip
#undef linecounter
 cur = 11; return; }
#line 283 "<stdout>"
yy23:	yych = *(YYMARKER = ++YYCURSOR);
	goto yy29;
yy24:
#line 97 "GUI/detail/gss-grammar.h.re"
{ semanticError(std::string("Unknown character '") + *begin + "'"); goto retry; }
#line 289 "<stdout>"
yy25:	++YYCURSOR;
	goto yy26;
yy26:
#line 96 "GUI/detail/gss-grammar.h.re"
{ cur = 0; return; }
#line 295 "<stdout>"
yy27:	yych = *++YYCURSOR;
	goto yy24;
yy28:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy29;
yy29:	switch(yych){
	case '"':	goto yy30;
	default:	goto yy28;
	}
yy30:	++YYCURSOR;
	goto yy31;
yy31:
#line 88 "GUI/detail/gss-grammar.h.re"
{ 
#define b (begin)
#define e (YYCURSOR)
 cur = 8; curData.reset(new STRING(*self, b + 1, e - 1)); return; 

#undef b
#undef e
}
#line 318 "<stdout>"
yy32:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy33;
yy33:	switch(yych){
	case 0x00:	case 0x0A:	case 0x0D:	goto yy2;
	case '%':	case '(':
	case ')':	case '-':
	case '.':
	case '/':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':	case '\\':	case '_':	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy32;
	default:	goto yy36;
	}
yy34:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy35;
yy35:	switch(yych){
	case '%':	case '(':
	case ')':	case '-':
	case '.':
	case '/':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':	case '\\':	case '_':	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy34;
	default:	goto yy2;
	}
yy36:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy37;
yy37:	switch(yych){
	case 0x00:	case 0x0A:	case 0x0D:	goto yy38;
	default:	goto yy36;
	}
yy38:
#line 66 "GUI/detail/gss-grammar.h.re"
{ 
#define linecounter() (++this->line)
#define skip() goto retry
#define append() goto append
#define setstate(x_) (state = (x_))
 skip(); 
#undef setstate
#undef append
#undef skip
#undef linecounter
 cur = 10; return; }
#line 483 "<stdout>"
}
#line 98 "GUI/detail/gss-grammar.h.re"

break;
}
#undef YYCTYPE
#undef YYCURSOR
#undef YYLIMIT
#undef YYMARKER
#undef YYFILL
}
void fill(size_t s) {
size_t l = limit - begin;
if(buffer)
	memmove(buffer, begin, l);
size_t newSize = std::max(static_cast<size_t>(1024), l + s);
buffer = (char *)realloc(buffer, newSize);
size_t toRead = newSize - l;
size_t amountRead = self->read(&buffer[l], toRead);
if(amountRead == 0) { memset(&buffer[l], 0, toRead); }
else newSize = l+amountRead;
ptrdiff_t offs = buffer - begin;
curp += offs;
marker += offs;
begin = buffer;
limit = buffer + newSize;
}
struct ParsingAborted : public std::exception { };
void fatalError(std::string const& msg = "Syntax error") {
self->reportError(msg, self->getLoc());
throw ParsingAborted();
}
void syntaxError(std::string const& msg = "Syntax error") {
syntaxError(msg, self->getLoc());
}
void syntaxError(std::string const& msg, Location loc) {
self->reportError(msg, loc);
syncTokens = true;
error = true;
}
void semanticError(std::string const& msg = "Semantic error") {
semanticError(msg, self->getLoc());
}
void semanticError(std::string const& msg, Location loc) {
self->reportError(msg, loc);
error = true;
}
void semanticWarning(std::string const& msg = "Semantic warning") {
semanticWarning(msg, self->getLoc());
}
void semanticWarning(std::string const& msg, Location loc) {
self->reportError("warning: " + msg, loc);
}
bool matchToken(int token) {
if(syncTokens) {
while(cur != token && cur != 0) next();
if(cur == 0 && token != 0) fatalError("Unexpected end of file");
syncTokens = false;} else {
if(cur != token) {
syntaxError("Unexpected token");
return false;
 }}
return true; }
bool optionalMatch(int token) {
if(syncTokens) {
while(cur != token && cur != 0) next();
syncTokens = false;if(cur != token) return false;
} else {
if(cur != token) {
return false;
 }}
return true; }
bool full() { return cur == 0 && !error; }
void rule_clause() {
 Context::GSSselector& sel = self->addSelector(); 
while(set_1[cur]) {
if((cur == 1)) {
next();
if(!matchToken(8)) return;
std::auto_ptr<STRING> class_(static_cast<STRING*>(curData.release()));
next();
 sel.addClass(class_->str); 
}
else if((cur == 2)) {
next();
if(!matchToken(8)) return;
std::auto_ptr<STRING> id(static_cast<STRING*>(curData.release()));
next();
 sel.addID(id->str); 
}
else if((cur == 3)) {
next();
if(!matchToken(8)) return;
std::auto_ptr<STRING> state(static_cast<STRING*>(curData.release()));
next();
 sel.addState(state->str); 
}
else if((cur == 8)) {
std::auto_ptr<STRING> tag(static_cast<STRING*>(curData.release()));
next();
 sel.addTag(tag->str); 
}
else { syntaxError(); return; }
}
if(!matchToken(5)) return;
next();
rule_property(sel);
while((cur == 4)) {
next();
if((cur == 8)) {
rule_property(sel);
}
}
if(!matchToken(6)) return;
next();
}
void rule_document() {
while(set_1[cur]) {
rule_clause();
}
}
void rule_property(Context::GSSselector& sel) {
std::auto_ptr<STRING> name(static_cast<STRING*>(curData.release()));
next();
if(!matchToken(3)) return;
next();
 std::list<std::string>& v = sel.addProperty(name->str); 
while(set_7[cur]) {
if((cur == 8)) {
std::auto_ptr<STRING> value(static_cast<STRING*>(curData.release()));
next();
 v.push_back(value->str); 
}
else if((cur == 2)) {
next();
if(!matchToken(8)) return;
std::auto_ptr<STRING> value(static_cast<STRING*>(curData.release()));
next();
 v.push_back('#' + value->str); 
}
else { syntaxError(); return; }
}
}
bool set_1[13];
bool set_7[13];
TGrammar() : cur(-1), begin(0), marker(0), buffer(0), curp(0), limit(0), line(1), syncTokens(false), error(false), state(0) {
memset(set_1, 0, sizeof(bool)*13);
set_1[1] = true;
set_1[2] = true;
set_1[3] = true;
set_1[8] = true;
memset(set_7, 0, sizeof(bool)*13);
set_7[2] = true;
set_7[8] = true;
}
int cur;
std::auto_ptr<Token> curData;
char* curp;
char* limit;
char* marker;
char* begin;
char* buffer;
int line;
int state;
bool syncTokens;
bool error;
#undef self
};
}
